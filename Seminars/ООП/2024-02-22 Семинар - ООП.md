---
tags:
  - seminar
  - 2nd-semester
  - 2024-02-22
  - ооп
---
```cpp
#include <stdexcept>
#include <iostream>

class Fraction
{
private:
	int numerator;
	int denominator;

public:
	Fraction(int n, int d)
	{
		numerator = n;
		if (d != 0)
		{
			denominator = d;
		}
		else
		{
			throw std::invalid_argument("fraction denominator cannot be \"0\"");
		}
	}
	Fraction(int n)
	{
		numerator = n;
		denominator = 1;
	}
	Fraction()
	{
		numerator = 1;
		denominator = 0;
	}

	void setNumerator(int value) { numerator = value; }
	void setDenominator(int value)
	{
		if (value != 0)
		{
			denominator = value;
		}
		else
		{
			throw std::invalid_argument("fraction denominator cannot be \"0\"");
		}
	}

	int getNumerator() { return numerator; }
	int getDenominator() { return denominator; }

	Fraction operator-() { return Fraction(-numerator, denominator); }
	Fraction operator*(int num) { return Fraction(numerator * num, denominator); }
	Fraction operator*(Fraction frac) { return Fraction(numerator * frac.numerator, denominator * frac.denominator); }
	Fraction operator/(Fraction frac) { return Fraction(numerator * frac.denominator, denominator * frac.numerator); }

	bool operator==(int num) { return numerator == num * denominator; }
	bool operator!=(int num) { return numerator != num * denominator; }
	bool operator>(int num) { return numerator > num * denominator; }
	bool operator<(int num) { return numerator < num * denominator; }
	bool operator>=(int num) { return numerator >= num * denominator; }
	bool operator<=(int num) { return numerator <= num * denominator; }

	bool operator==(Fraction frac)
	{
		return (numerator * frac.denominator - denominator * frac.numerator) == 0;
	}
	bool operator!=(Fraction frac)
	{
		return (numerator * frac.denominator - denominator * frac.numerator) != 0;
	}
	bool operator>(Fraction frac)
	{
		return (numerator * frac.denominator - denominator * frac.numerator) / (denominator * frac.denominator) > 0;
	}
	bool operator<(Fraction frac)
	{
		return (numerator * frac.denominator - denominator * frac.numerator) / (denominator * frac.denominator) < 0;
	}
	bool operator>=(Fraction frac)
	{
		return (numerator * frac.denominator - denominator * frac.numerator) / (denominator * frac.denominator) >= 0;
	}
	bool operator<=(Fraction frac)
	{
		return (numerator * frac.denominator - denominator * frac.numerator) / (denominator * frac.denominator) <= 0;
	}

	Fraction operator*=(Fraction frac)
	{
		*this = *this * frac;
		return *this;
	}

	// Friendly function prototype
	friend Fraction operator/(int num, Fraction frac);

	void print() { std::cout << numerator << "/" << denominator << "\n"; }
};

Fraction operator*(int num, Fraction frac)
{
	return Fraction(frac.getNumerator() * num, frac.getDenominator());
}

// Friendly function implementation
Fraction operator/(int num, Fraction frac)
{
	Fraction numFrac = Fraction(num, 1);
	return Fraction(numFrac.numerator * frac.denominator, numFrac.denominator * frac.numerator);
}

int main()
{
	Fraction f1(1, 2);
	Fraction f2(3, 4);

	Fraction f3 = f1 * f2;
	Fraction f4 = f1 / f2;
	Fraction f5 = f1 * 3;
	Fraction f6 = -f1;

	f1.print();
	f2.print();
	f3.print();
	f4.print();
	f5.print();
	f6.print();
	std::cout << (f1 > f2) << "\n";

	(f1 *= Fraction(1, 3)).print();
	f1.print();

	Fraction f7 = 3 * f1;
	f7.print();

	return 0;
}
```