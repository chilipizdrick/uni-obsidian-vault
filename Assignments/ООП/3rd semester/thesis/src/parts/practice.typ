#import "../lib.typ": *
#show: fix-indent()

= Глава 2. Практическая реализация структуры данных суффиксного дерева <practice>

== Выбор структуры данных для хранения суффиксного дерева

Так как суффиксное дерево имеет древовидную структуру, то для его хранения
удобно использовать структуру дерева с произвольным количеством дочерних узлов.
В данной реализации используется класс дерева, где каждая вершина представлена в
виде класса `Node` (Код @code-Node), которая содержит следующие поля:

- `begin_index` - индекс начала подстроки, которая соответствует ребру, ведущему к
  данной вершине
- `end_index` - индекс конца подстроки, которая соответствует ребру, ведущему к
  данной вершине
- `parent` - указатель на родительскую вершину
- `suffix_link` - указатель на вершину, к которой ведет суффиксная ссылка
- `children` - ассоциативный массив (хеш-таблица), где ключом является символ, а
  значением - указатель на вершину, к которой ведет ребро с данным символом

#figure(
  ```cpp
    class Node {
      ...
      private:
        Node *parent;
        std::map<int, Node *> children;
        Node *suffix_link;
        int begin_index;
        int *end_index;
        int ID;
      ...
    };
  ```,
  caption: [Структура класса `Node`.],
) <code-Node>

Само суффиксное дерево представлено классом `SuffixTree` (Код @code-SuffixTree),
который содержит указатель на корневой элемент дерева (`root`), а также строку,
по которой строится дерево (`tree_string`). Также дерево будет содержать
следующие поля, необходимые для оптимальной работы алгоритма:

- `internal_node_ID` - идентификатор внутренней вершины (внутренняя вершина -
  вершина, не являющаяся корнем или листом дерева; не обязательно для работы
  алгоритма, но позволяет удобно хранить, визуализировать дерево, а также )
- `length` - длина строки, по которой строится дерево
- `current_end` - указатель индекс текущего конца строки
- `last_leaf_extension` - указатель на последний лист, который был добавлен в
  дерево

#figure(
  ```cpp
  class SuffixTree {
    ...
    private:
      std::string tree_string;
      Node *root;
      int internal_node_ID;
      int length;
      int *current_end;
      Node *last_leaf_extension;
    ...
  };
  ```,
  caption: [Структура класса `SuffixTree`.],
) <code-SuffixTree>

Также для реализации алгоритма было принято решение реализовать структуру `Suffix` (Код
@code-Suffix), непосредственно представляющую суффикс заданной строки. Структура
содержит следующие поля:

- `node` - указатель на вершину дерева, с которой связан данный суффикс Node
- `new_internal_node` - флаг, указывающий, что при продлении суффикса была создана
  новая внутренняя вершина
- `char_index` - индекс символа в строке, с которого начинается данный суффикс

#figure(
  ```cpp
  class Suffix {
    ...
    private:
      Node *node;
      bool new_internal_node;
      int char_index;
    ...
  };
  ```,
  caption: [Структура класса `Suffix`.],
) <code-Suffix>

== Реализация функций, задействованных при работе алгоритма

Как было упомянуто ранее, алгоритм Укконена построения суффиксного дерева
работает благодаря разделению работы всего алгоритма на применение трех правил
продления суффиксов.

+ Правило 1 --- продление листа: если текущий рассматриваемый суффикс, не считая
  его последнего символа, заканчивается в вершине дерева, то необходимо продлить
  лист, увеличив индекс окончания суффикса на 1 в соответствующей вершине.
+ Правило 2 --- ответвление, существует в двух вариациях:
  - если текущий рассматриваемый суффикс, не считая его последнего символа,
    заканчивается в ребре, то необходимо "разрезать" это ребро, создав новую
    внутреннюю вершину и два новых ребра, одним из которых станет изначальное
    окончание рассматриваемого ребра, а вторым - окончание рассматриваемого
    суффикса.
  - если текущий рассматриваемый суффикс, не считая его последнего символа,
    заканчивается в вершине, но не в ребре, то необходимо добавить новую вершину
    (лист) как дочернюю вершину данного внутреннего узла.
+ Правило 3 --- ничего не делать: если текущий суффикс, не считая его последнего
  символа, оканчивается на вершине / ребре дерева и из этой вершины / ребра дерева
  есть путь в последний символ рассматриваемого суффикса, тогда существующий
  суффикс уже присутствует в дереве и работу алгоритма можно прекратить на этой
  итерации, так как все последующие рассмотренные продления суффиксов в силу
  работы алгоритма будут происходить по 3-му правилу.

Применение данных правил осуществляется в ходе выполнения функций `SuffixTree::SPA` (Single
Phase Algorithm) (Код @code-SPA) и `SuffixTree::SEA` (Single Extension Algorithm)
(Приложение @appendix-SEA). Кодирование 2-го и 3-го правил продления суффиксов в коде программы
осуществляется при помощи перечисления `Rule` (Код @code-Rule).

#figure(
  ```cpp
      enum Rule { RULE_2, RULE_3 };
  ```,
  caption: [Перечисление `Rule`.],
) <code-Rule>

Алгоритм построения суффиксного дерева начинает свою работу при вызове функции `SuffixTree::constuct(std::string)` (Код
@code-construct). Первым шагом является инициализация всех необходимых значений, в
частности - вычисление длины строки, ко которой строится дерево, сохранение
самой строки, сдвиг текущего индекса, указывающего на конец строки с 0-го на
1-ый, а также первое продление суффикса, позволяющее начать последовательное
построение суффиксного дерева однофазовым алгоритмом `SuffixTree::SPA(int)` (Single
Phase Algorithm) (Код @code-SPA), который затем применяется для каждого последующего
символа строки (а точнее его индекса).

#figure(
  ```cpp
  void SuffixTree::construct(std::string s) {
      length = s.length();
      tree_string = s;
      (*current_end)++;
      last_leaf_extension = new Node(root, 1, current_end, 1);
      root->add_child(*this, last_leaf_extension);
      for (int i = 1; i < length; i++)
          SPA(i);
  }
  ```,
  caption: [Устройство функции `SuffixTree::construct`.],
) <code-construct>

Однофазовый алгоритм (Код @code-SPA) имеет такое название, так как представляет одну
итерацию алгоритма продления суффиксов в строящемся суффиксном дереве. Согласно
леммам, доказанным самим Эско Укконеном в оригинальной статье @book-ukkonen,
приведенный алгоритм продления суффиксов будет иметь временную сложность в $O(1)$,
что позволяет алгоритму иметь общую временную сложность в $O(n)$, где $n$ --- это
количество символов и изначальной строке.

Для начала, алгоритм инициализирует предыдущий построенный суффикс. Это
гарантированно можно сделать, так как в классе `SuffixTree` суффиксного дерева
храниться указатель на последний добавленный лист дерева, а также указатель на
индекс последнего добавленного в дерево символа строки. Затем рассматривается
следующий элемент в изначальной строке, и для каждого суффикса, начинающегося с
первого символа строки и заканчивающегося текущим символом, применяется
некоторое правило продления суффикса в ходе выполнения функции `SuffixTree::SEA` (Single
Extension Algorithm) (Приложение @appendix-SEA). Если примененное правило --- правило 3, то
алгоритм заканчивает текущую итерацию.

#figure(
  ```cpp
  void SuffixTree::SPA(int i) {
      Suffix previous_suffix(last_leaf_extension, *current_end);
      (*current_end)++;
      for (int j = (last_leaf_extension->ID + 1); j <= i + 1; j++) {
          Rule rule_applied = SEA(previous_suffix, j, i);
          if (rule_applied == RULE_3)
              break;
      }
  }
  ```,
  caption: [Устройство функции `SuffixTree::SPA`.],
) <code-SPA>

Алгоритм единого продолжения суффикса (Single Extension Algorithm) (Приложение @appendix-SEA)
является ключевым для работы алгоритма построения суффиксного дерева. В ходе
работы данного алгоритма обрабатывается предыдущий суффикс, который представлен
в виде структуры `Suffix`.Сначала строится новый суффикс, в зависимости от
условий, которые определяются в ходе работы данного алгоритма, применяется одно
из трех правил продления суффиксов. Реализация второго правила продления
суффикса находится функции `SuffixTree::RULE2` (Код @code-RULE2).
После продления суффикса алгоритм возвращает примененное для продления суффикса правило.

#figure(
  ```cpp
  void SuffixTree::RULE2(Suffix &suffix, int char_index,
                         int new_leaf_ID) {
      if (!suffix.ends_at_node()) {
          suffix.node->split_edge(*this, suffix.char_index,
                                  --internal_node_ID);
          suffix.node = suffix.node->parent;
          suffix.new_internal_node = true;
      }
      Node *new_leaf =
          new Node(suffix.node, char_index, current_end, new_leaf_ID);
      suffix.node->add_child(*this, new_leaf);
      last_leaf_extension = new_leaf;
  }
  ```,
  caption: [Устройство функции `SuffixTree::RULE2`.],
) <code-RULE2>

== Реализация вывода и ввода информации о дереве через потоки

Для реализации ввода и вывода информации о дереве через потоки были
перегружены операторы ввода и вывода `std::ostream& operator<<(std::ostream&, ...)` и
`std::istream& operator>>(std::istream&, ...)` для реализованных классов `SuffixTree`
и `Node` соответственно. При этом было принято использовать рекурсивную структуру
выходных и входных данных в связи с древесной структурой классов `SuffixTree` и `Node`.
В созданном формате фигурные скобки кодируют узел дерева, первый элемент в указанных
скобках --- идентификатор узла дерева, для узлов-листов дерева, он равняется индексу первого символа
кодируемого этим листом суффикса, второй элемент --- индекс начала кодируемой подстроки, 3-ий
элемент --- индекс конца кодируемой подстроки, 4-ый элемент --- идентификатор элемента, на
который указывает суффиксная ссылка и 5-ый элемент --- это список всех дочерних
узлов для данного узла.
Реализация указанных функций приведена в приложениях @appendix-ostream и @appendix-istream.
Результат работы упомянутых операторов ввода и вывода можно видеть на рисунках @image-operator-result
и @image-operator-result-2.

#figure(
  image("../images/raw-result.png"),
  caption: [Результат вызова оператора вывода для суффиксного дерева, построенного на слове _abbabac\$_.]
) <image-operator-result>

#figure(
  image("../images/construct-result.png"),
  caption: [Результат вызова оператора вывода и последующего вызова оператора
    ввода для суффиксного дерева, построенного на слове _abbabac\$_. Дерево
    сохранило свою структуру после сохранения и чтения из файла.]
) <image-operator-result-2>

== Реализация функции поиска заданного суффикса

Реализация функции поиска заданного суффикса `SuffixTree::find_suffix` (Код @code-find-suffix)
предполагает прохождение от корня до некоторого листа построенного суффиксного дерева
и сдвижении текущего индекса, по которому идет проверка на подходящие ребра в дерева
для данного суффикса. Если такого ребра не было найдено, то алгоритм прекращает работу
и возвращает -1. Если же такое ребро находится, то алгоритм продолжает работу до того
момента, пока индекс `curr_index` не достигнет конечного элемента искомого суффикса.
В таком случае индекс начала искомого суффикса и изначальном слове окажется равным
`curr_node->ID` и будет возвращен из функции.

#figure(
  ```cpp
  int SuffixTree::find_suffix(const std::string &suffix) {
      Node *curr_node = this->root;
      int curr_index = 0;
      while (curr_index < suffix.size()) {
          Node *initial_node = curr_node;
          for (auto const &[_, node] : curr_node->children) {
              if (this->tree_string.substr(node->begin_index - 1,
                                           node->edge_length()) ==
                  suffix.substr(curr_index, node->edge_length())) {
                  curr_node = node; curr_index += node->edge_length();
                  break;
              }
          }
          if (initial_node == curr_node) return -1;
      }
      return curr_node->ID;
  }
  ```, caption: [Реализация функции `SuffixTree::find_suffix`.]
) <code-find-suffix>

Пример работы функции поиска заданного суффикса для существующего и
несуществующего в изначальной строке суффикса можно видеть на рисунке @image-find-suffix-result.
В первом случае суффикс _abab\$_ --- найден, индекс
его первого символа в изначальной строке --- действительно 4
(строка --- 1-индексированная). Во втором случае суффикс _cab\$_ ---
не найден в строке, поэтому возвращена -1.

#figure(
  image("../images/find-suffix-result.png")
  , caption: [Демонстрация работы алгоритма поиска индекса заданного суффикса в
  дереве, построенном на строке _abbabac\$_.] 
) <image-find-suffix-result>

== Применение структуры данных суффиксного дерева для решения задачи о поиске длиннейшей повторяющейся подстроки

Задача о нахождении длиннейшей повторяющейся подстроки в данной строке решается
при помощи наивного алгоритма с временной сложностью $O(n^3)$. Очевидно, что даже
на тексте длинной несколько десятков тысяч символов такое решение будет работать
непозволительно медленно. Суффиксное дерево позволяет решить упомянутую задачу с
за линейное количество времени, так как при использовании суффиксного дерева задача
сводится к поиску длиннейшего пути из корня дерева к внутреннему узлу, имеющему 2
и более дочерних узлов. Задача имеет именно такую постановку, так как существование
такого внутреннего узла гарантирует, что в указанной входной строке будет хотя бы 2
места, таких, что искомая длиннейшая последовательность будет встречаться в тексте,
а за ней будут следовать разные окончания строки.

Для решения задачи о поиске длиннейшей повторяющейся подстроки в данной строке была
реализована функция `SuffixTree::LRS` (Longest Repeating Substring), представленная
в приложении @appendix-LRS. Работа функции заключается в рекурсивном вызове самой
себя для каждого из дочерних узлов, если они удовлетворяют упомянутому условию
внутреннего узла, и прибавлении закодированной их индексами подстроки к итоговому
результату. На последнем этапе выбирается строка максимальной длины из всех
полученных в результате работы алгоритма для данного рассматриваемого узла.
Такой порядок операций гарантирует нахождение длиннейшей повторяющейся подстроки
в исходной строке.

Для проверки реализованной функции возьмем текст романа Михаила Булгакова "Мастер
и Маргарита", содержащий 765326 символов. Если использовать реализацию на базе
наивного алгоритма и предположить, что полученный алгоритм будет обрабатывать порядка
$10^9$ символов в секунду, то поиск решения займет приблизительно
$765326^3 dot 10^(-9) approx 4.48 dot 10^8$ секунд, что приблизительно равно $14.2$
годам. Использующий же в своей реализации структуру суффиксного дерева алгоритм
позволит решить поставленную задачу за $1.03$ секунд. Работа алгоритма
представлена в на рисунке @image-lrs-result.

#figure(
  image("../images/lrs-result.png"), caption: [Демонстрация работы алгоритма поиска длиннейшей повторяющейся подстроки с применением структуры суффиксного дерева в свой реализации.] 
) <image-lrs-result>
