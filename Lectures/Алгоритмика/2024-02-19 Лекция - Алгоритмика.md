---
tags:
  - lecture
  - 2nd-semester
  - 2024-02-19
  - алгосы
---

```julia
typeof(Int64) # DataType
typeof(Complex) # UnionAll
```

## Функция для вывода дерева типов

```julia
function subtype_tree!(type::Union{DataType, UnionAll}, indentation::Int64)
	print(" "^indentation)
	println(type)
    indentation += 2
	for subtype in subtypes(type)
		subtype_tree!(subtype, indentation)
	end
end

subtype_tree!(Number, 2)
# Number
#   Base.MultiplicativeInverses.MultiplicativeInverse
#     Base.MultiplicativeInverses.SignedMultiplicativeInverse
#     Base.MultiplicativeInverses.UnsignedMultiplicativeInverse
#   Complex
#   Real
#     AbstractFloat
#       BigFloat
#       Float16
#       Float32
#       Float64
#     AbstractIrrational
#       Irrational
#     Integer
#       Bool
#       Signed
#         BigInt
#         Int128
#         Int16
#         Int32
#         Int64
#         Int8
#       Unsigned
#         UInt128
#         UInt16
#         UInt32
#         UInt64
#         UInt8
#     Rational
```

## Float types

### Нормализованная двоичная мантисса

$$1 \leq MANTISSA < 2 \implies \text{первый бит мантиссы необязательно хранить}$$

### Определение ближайшего машинного нуля

```julia
eps(x) # returns nearest machine epsilon
```

## Причины потери точности

1) Денормализация
2) Переполнение порядка
3) Исчезновение порядка (машинный ноль)

## Быстрое возведение в степень

$a \in \mathbb{R}$, $n \in \mathbb{Z}^{+}$, $a^{n} - ?$.

### Наивное решение (O(n))

```julia
function slowpow(a, n)
	p = 1
	for _ in 1:n
		p *= a
	end
	return p
end
```

### Быстрое решение (O(log(n)))

Инвариант цикла: $a^{n} = p^{k}\cdot t$
```julia
function fastpow(a, n)
	p = a
	k = n
	t = 1
	while k > 0
		if even(k)
			k /= 2
			p *= p
		else
			k -= 1
			t *= p
		end
	end
	return p
end
```

## Быстрое нахождение чисел Фиббоначи

Формула Бене:

$$f_{n} = \frac{\left( \frac{1+\sqrt{ 5 }}{2} \right)^{n} - \left( \frac{1-\sqrt{ 5 }}{2} \right)^{n}}{\sqrt{ 5 }}$$

Данный вариант не подходит для больших чисел из-за погрешностей чисел с плавающей точкой.

$$\begin{bmatrix}
1 & 1 \\
0 & 1
\end{bmatrix}\begin{bmatrix}
1_{f_{2}} \\
1_{f_{1}}
\end{bmatrix} = \begin{bmatrix}
2_{f_{3}} \\
1_{f_{3}}
\end{bmatrix} \dots$$