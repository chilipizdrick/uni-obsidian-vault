---
tags:
  - lecture
  - 2nd-semester
  - 2024-05-03
---

## Очередь с приоритетом (Priority queue)

Очередь с приоритетом работает как обычная очередь, но при добавлении нового элемента размещает его после всех элементов с меньшим приоритетом.

## Поиск в ширину (BFS - Breadth First Search)

Поиск в ширину ищет минимальное расстояние от стартовой вершины до остальных.
Дана матрица смежности $M$, число вершин $n$ и стартовая позиция $s = 0$. Мы хотим $[d(0), d(1), \dots, d(n)]$, где $d(i)$ - наименьшее расстояние между вершинами $i$ и $s$. Вот Python код:

```python
used = [-1] * n
used[s] = 0
q = Queue()

q.push(s)
while len(q) != 0:
	current = q.pop()
	for i in range(n):
		if matrix[curr][i] != 0 and used[i] == -1:
			used[i] = used[curr] + 1
			q.push(i)
```

Врем. сложность: $O\left( |V| + \sum \deg V \right) = O(|V| + |E|)$

> [!important] Лемма 1
> $$(u,v) \in E \implies d(v) \leq d(u) + 1$$

> [!important] Лемма 2
> Пусть дан кратчайший путь из $s$ в $v$.
> $$s = u_{1}, \ \left\{ (u_{1},u_{2}), (u_{2},u_{3}), \dots, (u_{k-1}, u_{k}) \right\}$$
> Тогда
> $$\forall i < k, \ d(u:) + 1 = d(u: + 1)$$

> [!note] Доказательство
> 1. Расстояние при добавлении вершины неизменно.
> $$d(j_{\text{neigh.}}) = d(j) + 1$$
> 2. Функция верно считает кратчайшее расстояние.
> Индукция по числу операций: ($d(u)$ - фактическое кратчайшее расстояние, $dist(u)$ - расстояние, которое мы получили)
> 2.1. База: очев.
> 2.2. $dist[v] + 1 < dist[u]$. Пусть $dist[v] + 1 \neq d(u)$. Тогда $d(u) < dist(v) + 1$. Рассмотрим $w$ - предположительная вершина из $s$ в $u$. Тогда $d(w) + 1 = d(u)$. $d(w) + 1 < dist(v) + 1 \implies d(w) < dist(v)$, откуда следует, что $w$ - извлекли (pop()) раньше, чем извлекли $v$. Значит уже добавили и скорректировали расстояние. 

## Поиск в глубину (DFS - Depth First Search)

Задача: найти любой путь скорейшим образом из $v$ в $u$.
Условие такое же как и в BFS, но в исполнении меняем очередь на стек и начальное расстояние считаем единичным.

```python
used = [-1] * n
used[s] = 1 # 0 -> 1
q = Stack() # Queue() -> Stack()

q.push(s)
while len(q) != 0:
	current = q.pop()
	for i in range(n):
		if matrix[curr][i] != 0 and used[i] == -1:
			used[i] = 1 # used[i] + 1 -> 1
			q.push(i)
```

## Алгоритм Дейкстры


